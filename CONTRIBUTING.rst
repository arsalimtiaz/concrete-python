How to contribute code
======================

1. Create an issue on Gitlab.
2. If you are adding new functionality, create a stub implementation
   of the desired argument/function/class/etc.
3. Write a test for your new functionality/bugfix and run it, ensuring
   that it fails on the current implementation::

      py.test tests/test_my_code.py

   NameErrors, ImportErrors, SyntaxErrors, etc. do *not* count.
4. Implement your new functionality/bugfix.
5. Run the test again, ensuring that it now passes.
6. Run all tests and style checks, ensuring that they pass::

       tox

   Optionally, run integration tests (you must have Redis_ server
   version 2.8 or later in your path; do ``redis-server --version``
   to check)::

       tox integration-tests

7. Push your changes to a feature branch on Gitlab (e.g., called
   ``n-issue-abbrev`` where ``n`` is the issue number and
   ``issue-abbrev`` is a very short abbreviation of the issue title)
   and ensure that the build passes.  The build is defined in
   ``.gitlab-ci.yml`` (``.travis.yml`` and ``appveyor.yml`` for public
   builds); tox is configured in ``tox.ini``.  The build
   includes unit tests, integration tests, and style checks; if it
   fails, please find the error in the build log, fix it, and try
   again.
8. Add a line to ``CHANGELOG`` under the current version-in-progress
   describing your changes simply and concisely.
9. If you've made multiple commits, please squash them and
   ``git push -f`` to the feature branch.
10. Create a merge request for your feature branch into ``master``,
    referencing the Gitlab issue.


For maintainers
===============

Branches, versions, and releases
--------------------------------

The master branch is kept stable at all times.  Before a commit is
pushed to master, it should be checked by CI on another branch.  The
recommended way of maintaining this is to do all work in feature
branches that are kept up-to-date with master and pushed to Gitlab,
waiting for CI to finish before merging.

All stable versions can be (and are) released to PyPI.  In between
these, beta versions are used to denote significant changes to the code
that we wish to deploy to users tracking master.

The script ``release.bash`` can automate the release process.  It
should be run after all changes are committed to master and CI has
passed, but before the version (in ``concrete/version.py``) has been
incremented to a stable version.

For example, if the version in ``concrete/version.py`` is 4.13.4b7, to
release 4.13.4, ``release.bash`` does the following:

* ``git reset --hard``
* ``git clean -f -d -x``
* Increase master version to 4.13.4 and commit
* ``python setup.py sdist``
* ``twine upload dist/*``
* ``git tag -am v4.13.4 v4.13.4``
* Increase master version to 4.13.5b0 and commit
* ``git push gitlab master v4.13.4``

In words, we clean the repository, update to a stable version number
and commit, build the release tarball, upload the release tarball to
PyPI, tag the release, update to the next beta version number and
commit (so that subsequent development on master is linked to the next
version), and push the release tag and the new development version of
master to Gitlab.

Run ``bash release.bash -h`` for usage information.

Testing PyPI releases
---------------------

To test how changes to concrete-python will show up on PyPI (for
example, how the readme is rendered) you can use the PyPI testing
site.  To do so, set the following in ``~/.pypirc``::

    repository = https://testpypi.python.org/pypi

You will also need to create a testpypi user account and you may need
to request access to the ``concrete`` package on testpypi.

(Re)generating code from concrete
---------------------------------

The Python code generated by the thrift compiler on the schema defined
in the concrete project is checked in to concrete-python manually after
applying necessary patches.  For *trivial* modifications to the schema
this process is automated by ``generate.bash``, which assumes concrete
has been cloned alongside concrete-python (in the same parent
directory)::

    bash generate.bash

After this succeeds, tests should be run and the changes should be
manually inspected (``git diff``) for sanity.  Note that this will not
delete previously-generated files that are no longer produced by
thrift (whose entries were removed from the schema).

Often ``generate.bash`` is not sufficient: the patches (in
``patches/``) document where it (thrift) falls short on the
previously-compiled schema.  If ``generate.bash`` throws an error, the
necessary changes should be performed manually and checked in to the
index, at which point the generated code should be removed from the
working tree, raw (unpatched) generated code should be generated, and
new patches should be produced and stored in ``patches/`` using
``git diff``.  See the arguments to ``generate.bash`` for generating
the unpatched code.



.. _Redis: http://redis.io
